<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UNKNOWN.exe</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: radial-gradient(ellipse at 50% 40%, #0a0c1a 70%, #010012 100%);
      font-family: 'Share Tech Mono', 'Consolas', monospace;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      color-scheme: dark;
    }
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: repeating-linear-gradient(
        135deg,
        #171b23 0px,
        #171b23 10px,
        #13141a 10px,
        #13141a 20px
      ), radial-gradient(circle at 50% 60%, #263445 50%, #0a0c1a 100%);
      border-radius: 28px;
      box-shadow:
        0 0 80px #00ffd088,
        0 0 64px #09f5ff99 inset,
        0 0 0 8px #1a1a2f,
        0 2px 32px #000d,
        0 0 0 4px #00ffd055;
      border: 6px solid #00ffd0;
      position: relative;
      z-index: 2;
      transition: box-shadow 0.2s;
      outline: 8px solid #061826;
    }
    #arcadeBezel {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 900px;
      height: 720px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 2;
      border-radius: 32px;
      box-shadow: 0 0 48px 24px #0ff3, 0 0 0 16px #2a2a3f, 0 0 160px 0 #00ffd033 inset;
      border: 8px double #00fff8cc;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      mix-blend-mode: lighten;
      opacity: 0.8;
    }
    #glitchOverlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      pointer-events: none;
      z-index: 10;
      mix-blend-mode: lighten;
      transition: opacity 0.1s;
    }
    #hud {
      position: fixed;
      top: 2vh; right: 5vw;
      color: #00ffd0;
      font-family: 'Share Tech Mono', monospace;
      z-index: 20;
      font-size: 1.3em;
      text-shadow: 0 0 10px #00ffd0, 0 0 2px #fff, 0 0 20px #0ff;
      user-select: none;
      pointer-events: none;
      letter-spacing: 0.04em;
    }
    #niceJobMsg {
      position: absolute;
      left: 50%;
      top: 18%;
      transform: translateX(-50%);
      color: #ffeb3b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 2.2em;
      text-shadow: 0 0 16px #fff700, 0 0 4px #fff, 0 0 32px #f5e802;
      background: rgba(20,20,20,0.35);
      padding: 0.2em 1.25em;
      border-radius: 14px;
      opacity: 0;
      pointer-events: none;
      z-index: 200;
      transition: opacity 0.4s;
    }
    #shopOverlay {
      position: fixed;
      left: 0; top: 0;
      width: 100vw; height: 100vh;
      background: rgba(10,16,24,0.96);
      z-index: 1001;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      user-select: none;
    }
    #shopWindow {
      background: linear-gradient(135deg, #161a26 80%, #0f1a1e 100%);
      border-radius: 24px;
      box-shadow: 0 0 60px #00ffd088, 0 0 0 8px #1a1a2f;
      padding: 38px 38px 24px 38px;
      min-width: 420px;
      min-height: 320px;
      color: #fff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1.21em;
      position: relative;
      margin-top: 3vh;
    }
    #shopTitle {
      font-size: 2.3em;
      color: #00ffd0;
      letter-spacing: 0.07em;
      text-shadow: 0 0 18px #0ff, 0 0 2px #fff, 0 0 22px #0ff;
      margin-bottom: 10px;
      margin-top: -16px;
      text-align: center;
    }
    #shopBalance {
      color: #ffe100;
      font-size: 1.3em;
      margin-bottom: 13px;
      text-align: center;
      text-shadow: 0 0 6px #ffe10099;
    }
    .shopUpgradeList {
      max-height: 340px;
      overflow-y: auto;
      margin-bottom: 18px;
      margin-top: 5px;
    }
    .shopUpgrade {
      background: #1c2840dd;
      border-radius: 10px;
      margin-bottom: 12px;
      padding: 11px 13px 10px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 0 9px #0ff4 inset;
    }
    .shopUpgradeTitle {
      font-size: 1.13em;
      color: #00ffd0;
      margin-bottom: 2px;
    }
    .shopUpgradeDesc {
      font-size: 0.97em;
      color: #b9f0ff;
    }
    .shopUpgradeBtn {
      background: linear-gradient(90deg, #ffe100 60%, #ffd400 100%);
      border: none;
      border-radius: 7px;
      color: #333;
      padding: 7px 16px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1.01em;
      margin-left: 20px;
      cursor: pointer;
      box-shadow: 0 0 8px #ffe10088;
      transition: background 0.14s;
    }
    .shopUpgradeBtn:disabled {
      background: #333a4a;
      color: #999;
      box-shadow: none;
      cursor: not-allowed;
    }
    #shopCloseBtn {
      position: absolute;
      right: 18px;
      top: 12px;
      background: #ff0044;
      color: #fff;
      font-size: 1.2em;
      border: none;
      border-radius: 7px;
      padding: 2px 15px 2px 15px;
      cursor: pointer;
      box-shadow: 0 0 10px #ff0044bb;
      transition: background 0.13s;
    }
    #shopCloseBtn:hover { background: #e3003c; }
    #shopOpenBtn {
      position: fixed;
      left: 2vw;
      top: 2vh;
      color: #ffe100;
      background: #182a20cc;
      border: 2px solid #ffe100;
      border-radius: 11px;
      padding: 6px 18px 7px 18px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1.09em;
      box-shadow: 0 0 8px #ffe10088;
      cursor: pointer;
      z-index: 1002;
      transition: background 0.14s;
    }
    #shopOpenBtn:active { background: #222e18; }
    #shopHint {
      color: #b9f0ff;
      font-size: 0.98em;
      margin: 0 0 0 3px;
      text-align: center;
    }
  </style>
  <link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono&display=swap" rel="stylesheet">
</head>
<body>
  <div id="arcadeBezel"></div>
  <div id="arcadeTop"></div>
  <div id="arcadeBottom"></div>
  <div id="arcadeLights"></div>
  <div id="container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="glitchOverlay"></div>
    <div id="hud"></div>
    <div id="niceJobMsg"></div>
    <button id="shopOpenBtn" title="Open Shop">Shop</button>
    <div id="shopOverlay">
      <div id="shopWindow">
        <button id="shopCloseBtn">âœ•</button>
        <div id="shopTitle">ARCADE SHOP</div>
        <div id="shopBalance">Balance: 0</div>
        <div class="shopUpgradeList" id="shopUpgradeList"></div>
        <div id="shopHint">Upgrades are permanent! Earn more by playing.<br>Press <b>Shop</b> during the game or after dying.</div>
      </div>
    </div>
  </div>
  <script>
    // --------- ARCADE SOUND EFFECTS SYSTEM (NO SONG) -----------
    let audioCtx, musicGain;
    function setupAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        musicGain = audioCtx.createGain();
        musicGain.gain.value = 0.19;
        musicGain.connect(audioCtx.destination);
      }
    }
    function playHealSound() {
      setupAudio();
      if (!audioCtx) return;
      // Chime sound
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.linearRampToValueAtTime(1400, t + 0.15);
      gain.gain.value = 0.19;
      osc.connect(gain).connect(musicGain);
      osc.start(t);
      osc.stop(t + 0.16);
      gain.gain.setValueAtTime(0.19, t);
      gain.gain.linearRampToValueAtTime(0.01, t + 0.16);
      osc.onended = () => { osc.disconnect(); gain.disconnect(); };
    }
    function playArcadeClick() {
      setupAudio();
      try {
        if (!audioCtx) return;
        const ctx2 = audioCtx;
        const o = ctx2.createOscillator();
        const g = ctx2.createGain();
        o.type = 'square';
        o.frequency.value = 260 + Math.random()*80;
        g.gain.value = 0.08;
        o.connect(g); g.connect(musicGain);
        o.start(0); o.stop(ctx2.currentTime + 0.065);
        setTimeout(()=>{try{o.disconnect();g.disconnect();}catch{}}, 120);
      } catch{}
    }

    // --------- "Nice Job" Message Logic -----------
    const niceJobMsg = document.getElementById('niceJobMsg');
    let niceJobTimeout = null;
    const niceJobNames = [
      "Jacob", "Alex", "Michael", "Sophia", "Taylor", "Jordan", "Chris", "Morgan", "Casey", "Sam", "Jamie", "Riley"
    ];
    function showNiceJob() {
      const randomName = niceJobNames[Math.floor(Math.random() * niceJobNames.length)];
      niceJobMsg.textContent = `${randomName}: Nice Job!`;
      niceJobMsg.style.opacity = "1";
      clearTimeout(niceJobTimeout);
      niceJobTimeout = setTimeout(() => {
        niceJobMsg.style.opacity = "0";
      }, 900 + Math.random()*500);
    }

    // --------- SHOP LOGIC -----------
    // Shop Upgrades List
    const upgrades = [
      {
        key: "maxHp",
        title: "Maximum Health +1",
        desc: "Increase your player's max health by 1.",
        baseCost: 200,
        costScale: 1.45,
        maxLevel: 7,
        getEffect: level => ({ maxHp: level }),
      },
      {
        key: "speed",
        title: "Speed Boost",
        desc: "Move faster each level. (Stackable)",
        baseCost: 150,
        costScale: 1.6,
        maxLevel: 8,
        getEffect: level => ({ speed: 0.13 * level }),
      },
      {
        key: "regen",
        title: "Passive Regen",
        desc: "Regenerate 1 HP every 20 sec. (Stackable)",
        baseCost: 700,
        costScale: 2.1,
        maxLevel: 3,
        getEffect: level => ({ regen: level }),
      },
      {
        key: "fireRate",
        title: "Faster Fire",
        desc: "Shoot faster. (Stackable)",
        baseCost: 180,
        costScale: 1.65,
        maxLevel: 7,
        getEffect: level => ({ fireRate: level }),
      },
      {
        key: "bulletSpeed",
        title: "Bullet Speed++",
        desc: "Shots move faster and travel further.",
        baseCost: 180,
        costScale: 1.7,
        maxLevel: 7,
        getEffect: level => ({ bulletSpeed: level }),
      },
      {
        key: "bulletSize",
        title: "Bullet Size",
        desc: "Your bullets are larger and easier to hit with.",
        baseCost: 160,
        costScale: 1.6,
        maxLevel: 5,
        getEffect: level => ({ bulletSize: level }),
      },
      {
        key: "healDrop",
        title: "More Heals",
        desc: "Heals spawn more often.",
        baseCost: 250,
        costScale: 1.7,
        maxLevel: 6,
        getEffect: level => ({ healDrop: level }),
      },
      {
        key: "scoreBoost",
        title: "Score Multiplier",
        desc: "Earn more score per enemy.",
        baseCost: 400,
        costScale: 2.5,
        maxLevel: 8,
        getEffect: level => ({ scoreBoost: level }),
      },
      {
        key: "startShield",
        title: "Start Shield",
        desc: "Start each run with a brief invincibility shield.",
        baseCost: 700,
        costScale: 3.0,
        maxLevel: 1,
        getEffect: level => ({ startShield: level }),
      },
      {
        key: "pierce",
        title: "Bullet Pierce",
        desc: "Bullets pierce through 1 more enemy.",
        baseCost: 1350,
        costScale: 2.5,
        maxLevel: 3,
        getEffect: level => ({ pierce: level }),
      },
      {
        key: "healOnKill",
        title: "Life Steal",
        desc: "Small chance to heal on kill.",
        baseCost: 1100,
        costScale: 2.7,
        maxLevel: 2,
        getEffect: level => ({ healOnKill: level }),
      },
      {
        key: "doubleShot",
        title: "Double Shot",
        desc: "Fire a second shot at a slight angle.",
        baseCost: 2000,
        costScale: 3.5,
        maxLevel: 1,
        getEffect: level => ({ doubleShot: level }),
      },
      {
        key: "tripleShot",
        title: "Triple Shot",
        desc: "Fire three shots in a spread.",
        baseCost: 3300,
        costScale: 6.5,
        maxLevel: 1,
        getEffect: level => ({ tripleShot: level }),
      },
      {
        key: "bigBomb",
        title: "Big Bomb",
        desc: "Press B to clear all enemies (1 use per run, stackable).",
        baseCost: 2500,
        costScale: 2.7,
        maxLevel: 5,
        getEffect: level => ({ bigBomb: level }),
      }
    ];
    // Persistent player data (score balance, upgrades)
    let shopData = {
      balance: 0,
      upgrades: {},
    };
    // Load shopData from localStorage
    function loadShopData() {
      try {
        const d = localStorage.getItem('arcade-shopdata-v1');
        if (d) shopData = JSON.parse(d);
      } catch {}
      // Init missing upgrades
      upgrades.forEach(u => {
        if (!(u.key in shopData.upgrades)) shopData.upgrades[u.key] = 0;
      });
    }
    function saveShopData() {
      try { localStorage.setItem('arcade-shopdata-v1', JSON.stringify(shopData)); } catch {}
    }
    loadShopData();

    function getUpgradeLevel(key) {
      return shopData.upgrades[key] || 0;
    }
    function getUpgradeEffect(key) {
      const u = upgrades.find(x => x.key === key);
      return u.getEffect(getUpgradeLevel(key));
    }
    function applyAllUpgradeEffects() {
      // Called before each run
      let effects = {
        maxHp: 0,
        speed: 0,
        regen: 0,
        fireRate: 0,
        bulletSpeed: 0,
        bulletSize: 0,
        healDrop: 0,
        scoreBoost: 0,
        startShield: 0,
        pierce: 0,
        healOnKill: 0,
        doubleShot: 0,
        tripleShot: 0,
        bigBomb: 0
      };
      for (const u of upgrades) {
        if (shopData.upgrades[u.key] > 0) {
          const eff = u.getEffect(shopData.upgrades[u.key]);
          for (const k in eff) effects[k] += eff[k];
        }
      }
      return effects;
    }

    // SHOP UI
    const shopOverlay = document.getElementById('shopOverlay');
    const shopUpgradeList = document.getElementById('shopUpgradeList');
    const shopBalanceDiv = document.getElementById('shopBalance');
    const shopOpenBtn = document.getElementById('shopOpenBtn');
    const shopCloseBtn = document.getElementById('shopCloseBtn');
    function renderShop() {
      shopBalanceDiv.textContent = "Balance: " + shopData.balance;
      shopUpgradeList.innerHTML = "";
      upgrades.forEach((u, idx) => {
        const level = getUpgradeLevel(u.key);
        const maxed = level >= u.maxLevel;
        let cost = Math.floor(u.baseCost * Math.pow(u.costScale, level));
        const div = document.createElement('div');
        div.className = 'shopUpgrade';
        const infoDiv = document.createElement('div');
        infoDiv.style.flex = "1";
        infoDiv.innerHTML = `<div class="shopUpgradeTitle">${u.title} ${maxed ? "(MAX)" : (level > 0 ? `Lv.${level}` : "")}</div>
          <div class="shopUpgradeDesc">${u.desc}</div>`;
        div.appendChild(infoDiv);
        const btn = document.createElement('button');
        btn.className = 'shopUpgradeBtn';
        btn.textContent = maxed ? "Maxed" : ("Buy ("+cost+")");
        btn.disabled = maxed || shopData.balance < cost;
        btn.onclick = () => {
          if (btn.disabled) return;
          shopData.balance -= cost;
          shopData.upgrades[u.key]++;
          saveShopData();
          renderShop();
        };
        div.appendChild(btn);
        shopUpgradeList.appendChild(div);
      });
    }
    shopOpenBtn.onclick = () => {
      renderShop();
      shopOverlay.style.display = 'flex';
    };
    shopCloseBtn.onclick = () => {
      shopOverlay.style.display = 'none';
    };
    // ESC closes shop
    document.addEventListener("keydown", e => {
      if (e.key === "Escape" && shopOverlay.style.display === "flex") {
        shopOverlay.style.display = "none";
      }
    });

    // --------- GAME CODE -----------
    window.addEventListener('DOMContentLoaded', function () {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const overlay = document.getElementById('glitchOverlay');
      const hud = document.getElementById('hud');

      // Mouse controls
      let mouseDown = false;
      let mouseX = canvas.width / 2, mouseY = canvas.height / 2;

      // Controls
      let keys = {};
      document.addEventListener('keydown', e => {
        keys[e.key] = true;
        if (e.key === 'r' && gameOver && !exploding && shopOverlay.style.display !== "flex") restartGame();
        if (e.key === "b" && !gameOver && !exploding && player.bigBombs > 0) {
          useBigBomb();
        }
      });
      document.addEventListener('keyup', e => {
        keys[e.key] = false;
      });
      canvas.addEventListener('mousedown', e => {
        if (e.button === 0) mouseDown = true;
      });
      canvas.addEventListener('mouseup', e => {
        if (e.button === 0) mouseDown = false;
      });
      canvas.addEventListener('mouseleave', e => {
        mouseDown = false;
      });
      canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
      });
      // Touch support for shooting
      canvas.addEventListener('touchstart', e => { mouseDown = true; });
      canvas.addEventListener('touchend', e => { mouseDown = false; });

      // Player
      let player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        size: 34,
        speed: 3.2,
        hp: 3,
        maxHp: 5,
        shootCooldown: 0,
        mouseCooldown: 0,
        color: '#00ffd0',
        regenTimer: 0,
        shieldTimer: 0,
        bigBombs: 0
      };

      // Bullets, enemies, heals
      let bullets = [];
      let enemies = [];
      let heals = [];
      let score = 0;
      let gameOver = false;
      let glitchTimer = 0;
      let tick = 0;
      let spawnTimer = 0;
      let healTimer = 0;
      let difficulty = 1;

      // Death explosion/fade
      let exploding = false;
      let explosionParticles = [];
      let explosionTimer = 0;
      let fadeAlpha = 0;
      let fadeStep = 0.025;

      // --- UPGRADES (applied per run)
      let upgradeEffects = {};

      function neonGradient(ctx, x, y, r1, r2, color1, color2) {
        const g = ctx.createRadialGradient(x, y, r1, x, y, r2);
        g.addColorStop(0, color1);
        g.addColorStop(1, color2);
        return g;
      }

      function drawPlayer() {
        if (exploding) return; // Don't draw player if exploding
        ctx.save();
        const {x, y, size} = player;
        const angle = -Math.PI/2 + Math.sin(tick/18)/6;
        // 3D Hexagon: side faces
        for(let face=0; face<6; face++) {
          const a1 = angle + Math.PI*2/6*face;
          const a2 = angle + Math.PI*2/6*(face+1);
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(a1)*size, y + Math.sin(a1)*size);
          ctx.lineTo(x + Math.cos(a2)*size, y + Math.sin(a2)*size);
          ctx.closePath();
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = face%2===0 ?
            "#002f4e" : "#0e1e24";
          ctx.shadowColor = face%2===0 ? "#00fff0" : "#0ff6";
          ctx.shadowBlur = 12;
          ctx.fill();
        }
        // Edge neon
        for (let layer=2; layer>=0; layer--) {
          ctx.beginPath();
          for (let j=0; j<6; j++) {
            const a = angle + Math.PI*2/6*j;
            const rad = size - (layer*2.5);
            ctx.lineTo(x + Math.cos(a)*rad, y + Math.sin(a)*rad*1.07);
          }
          ctx.closePath();
          ctx.strokeStyle = layer===0 ? "#6ff" : (layer===1 ? "#00ffd0cc" : "#3338ff15");
          ctx.shadowColor = layer===0 ? "#39fff6" : (layer===1 ? "#00ffd0" : "#0070ff");
          ctx.shadowBlur = layer===0 ? 24 : (layer===1 ? 17 : 8);
          ctx.lineWidth = layer===0 ? 4.2 : (layer===1 ? 8 : 12);
          ctx.globalAlpha = layer===0 ? 1.0 : (layer===1 ? 0.5 : 0.22);
          ctx.stroke();
        }
        // Top highlight
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y-size/2.4, size/1.9, Math.PI*1.12, Math.PI*1.93, false);
        ctx.strokeStyle = "#fff";
        ctx.globalAlpha = 0.13;
        ctx.lineWidth = 6;
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 24;
        ctx.stroke();
        ctx.restore();

        // Neon core ring
        ctx.beginPath();
        ctx.arc(x, y, size/2.1 + Math.sin(tick/7)*2.5, 0, 2*Math.PI);
        ctx.strokeStyle = "#00ff95";
        ctx.lineWidth = 4.6;
        ctx.shadowColor = "#10ffb0";
        ctx.shadowBlur = 22;
        ctx.globalAlpha = 0.88;
        ctx.stroke();

        // Inner glowing orb (futuristic)
        ctx.beginPath();
        ctx.arc(x, y, size/3.5 + Math.sin(tick/9)*1.3, 0, 2*Math.PI);
        ctx.fillStyle = neonGradient(ctx, x, y, 0, size/3.5+2, "#38fff6", "#000");
        ctx.globalAlpha = 0.93;
        ctx.fill();

        // Draw shield if active
        if (player.shieldTimer > 0) {
          ctx.save();
          ctx.globalAlpha = 0.4 + 0.2 * Math.sin(tick/5);
          ctx.beginPath();
          ctx.arc(x, y, size * 1.25, 0, 2 * Math.PI);
          ctx.strokeStyle = "#ffe100";
          ctx.lineWidth = 7;
          ctx.shadowColor = "#ffe100";
          ctx.shadowBlur = 24;
          ctx.stroke();
          ctx.restore();
        }
        ctx.restore();
      }

      function drawExplosion() {
        for (let p of explosionParticles) {
          ctx.save();
          ctx.globalAlpha = p.alpha;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
          ctx.fillStyle = p.color;
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 18;
          ctx.fill();
          ctx.restore();
        }
      }

      function drawBullets() {
        ctx.save();
        for (let b of bullets) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.size, 0, 2*Math.PI);
          ctx.shadowColor = b.colorGlow;
          ctx.shadowBlur = 24;
          ctx.globalAlpha = .93;
          ctx.fillStyle = b.color;
          ctx.fill();

          ctx.beginPath();
          ctx.arc(b.x, b.y, b.size*0.6, 0, 2*Math.PI);
          ctx.globalAlpha = 0.86;
          ctx.fillStyle = "#fff";
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      function drawEnemies() {
        ctx.save();
        for (let e of enemies) {
          ctx.save();
          ctx.translate(e.x, e.y);
          ctx.rotate(e.angle);
          if (e.type === "normal") {
            ctx.lineWidth = 3.5 + Math.random()*1.3;
            ctx.strokeStyle = "#fa0ead";
            ctx.shadowColor = "#ff00f8";
            ctx.shadowBlur = 18;
            ctx.beginPath();
            ctx.rect(-e.size/2, -e.size/2, e.size, e.size);
            ctx.globalAlpha = .93;
            ctx.stroke();
            ctx.globalAlpha = .14;
            ctx.fillStyle = "#55004f";
            ctx.fillRect(-e.size/2, -e.size/2, e.size, e.size);
          } else if (e.type === "fast") {
            ctx.strokeStyle = "#fffb00";
            ctx.shadowColor = "#fff700";
            ctx.shadowBlur = 16;
            ctx.lineWidth = 2.7;
            ctx.beginPath();
            ctx.ellipse(0, 0, e.size/1.13, e.size/2.6, Math.PI/4, 0, 2*Math.PI);
            ctx.globalAlpha = 0.95;
            ctx.stroke();
          } else if (e.type === "zigzag") {
            ctx.strokeStyle = "#00fff7";
            ctx.shadowColor = "#0ff";
            ctx.shadowBlur = 14;
            ctx.lineWidth = 2.7;
            ctx.beginPath();
            for(let i=0;i<=7;i++){
              ctx.lineTo(-e.size/2 + i*e.size/7, ((i%2)*2-1)*e.size/2.2);
            }
            ctx.globalAlpha = .93;
            ctx.stroke();
          }
          ctx.restore();
        }
        ctx.restore();
      }

      function drawHeals() {
        ctx.save();
        for (let h of heals) {
          ctx.save();
          ctx.translate(h.x, h.y);
          ctx.rotate(h.angle + Math.sin(tick/15));
          ctx.beginPath();
          for(let j=0;j<3;j++){
            const a = Math.PI*2/3*j - Math.PI/2;
            ctx.lineTo(Math.cos(a)*h.size, Math.sin(a)*h.size);
          }
          ctx.closePath();
          ctx.strokeStyle = "#0f8";
          ctx.lineWidth = 5;
          ctx.shadowColor = "#00ff83";
          ctx.shadowBlur = 22;
          ctx.globalAlpha = 0.92;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0, 0, h.size/2, 0, 2*Math.PI);
          ctx.globalAlpha = 0.23;
          ctx.fillStyle = "#00ff83";
          ctx.shadowBlur = 4;
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();
      }

      function drawUI() {
        ctx.save();
        ctx.font = "26px 'Share Tech Mono', monospace";
        ctx.fillStyle = "#00ffd0";
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 12;
        ctx.globalAlpha = .98;
        ctx.fillText(`SCORE: ${score}`, 32, 52);

        for(let i=0;i<player.maxHp;i++){
          ctx.beginPath();
          ctx.arc(56 + i*38, 98, 15, 0, 2*Math.PI);
          ctx.strokeStyle = i<player.hp ? "#00ffd0" : "#192e2a";
          ctx.lineWidth = 5.5;
          ctx.shadowColor = "#0ff";
          ctx.shadowBlur = i<player.hp ? 16 : 0;
          ctx.globalAlpha = i<player.hp ? 1 : 0.4;
          ctx.stroke();
          ctx.fillStyle = i < player.hp ? "#00ffd0" : "#1a1a2f";
          ctx.globalAlpha = .7;
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
        // Show bomb count if upgraded
        if (upgradeEffects.bigBomb > 0) {
          ctx.save();
          ctx.font = "23px 'Share Tech Mono', monospace";
          ctx.fillStyle = "#ffe100";
          ctx.shadowColor = "#ffe100";
          ctx.shadowBlur = 11;
          ctx.globalAlpha = 0.89;
          ctx.fillText(`Bombs: ${player.bigBombs}`, 32, 134);
          ctx.restore();
        }
        ctx.restore();

        hud.innerHTML = tick%300>150 && !gameOver && !exploding
          ? "<span class='flicker' style='color:#ff00d4;'>[DATA CORRUPTED]</span>"
          : `<span style="color:#00ffe0;text-shadow:0 0 12px #39fff6;">UNKNOWN<span style="color:#ff00d4;">.exe</span></span>`;
      }

      function drawDeathScreen() {
        // Fade to black
        ctx.save();
        ctx.globalAlpha = fadeAlpha;
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = Math.min(1, fadeAlpha * 2);
        ctx.font = "60px 'Share Tech Mono', monospace";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 24;
        ctx.fillText("You Died", canvas.width/2, canvas.height/2 - 20);
        ctx.font = "28px 'Share Tech Mono', monospace";
        ctx.shadowBlur = 2;
        ctx.fillText("(Press R to restart)", canvas.width/2, canvas.height/2 + 40);
        ctx.textAlign = "left";
        ctx.restore();
      }

      function movePlayer() {
        if (exploding) return;
        let dx=0, dy=0;
        if (keys['ArrowUp'] || keys['w']) dy -= 1;
        if (keys['ArrowDown'] || keys['s']) dy += 1;
        if (keys['ArrowLeft'] || keys['a']) dx -= 1;
        if (keys['ArrowRight'] || keys['d']) dx += 1;
        if (dx || dy) {
          const len = Math.sqrt(dx*dx+dy*dy);
          player.x += (player.speed + upgradeEffects.speed) * dx/(len||1);
          player.y += (player.speed + upgradeEffects.speed) * dy/(len||1);
        }
        let margin = player.size + 12;
        player.x = Math.max(margin, Math.min(canvas.width - margin, player.x));
        player.y = Math.max(margin, Math.min(canvas.height - margin, player.y));
      }

      function shoot(direction=null) {
        if (player.shootCooldown > 0 || exploding) return;
        let dx=0, dy=-1;
        if (direction) {
          let v = {x: direction.x - player.x, y: direction.y - player.y};
          let len = Math.sqrt(v.x*v.x + v.y*v.y);
          if (len > 0.1) { dx = v.x/len; dy = v.y/len; }
        }
        let bulletSpeed = 13 + upgradeEffects.bulletSpeed * 2.3;
        let bulletSize = 11 + upgradeEffects.bulletSize * 3;
        let pierce = 1 + (upgradeEffects.pierce || 0);
        let shots = [];
        // Determine spread
        if (upgradeEffects.tripleShot > 0) {
          shots.push({dx,dy,angle:0});
          shots.push({dx: Math.cos(Math.atan2(dy,dx)+0.22), dy: Math.sin(Math.atan2(dy,dx)+0.22), angle:0.22});
          shots.push({dx: Math.cos(Math.atan2(dy,dx)-0.22), dy: Math.sin(Math.atan2(dy,dx)-0.22), angle:-0.22});
        } else if (upgradeEffects.doubleShot > 0) {
          shots.push({dx,dy,angle:0});
          shots.push({dx: Math.cos(Math.atan2(dy,dx)+0.13), dy: Math.sin(Math.atan2(dy,dx)+0.13), angle:0.13});
        } else {
          shots.push({dx,dy,angle:0});
        }
        for (let shot of shots) {
          bullets.push({
            x: player.x + shot.dx*player.size,
            y: player.y + shot.dy*player.size,
            dx: shot.dx*bulletSpeed,
            dy: shot.dy*bulletSpeed,
            size: bulletSize,
            color: "#00ffe3",
            colorGlow: "#0ff",
            pierce: pierce
          });
        }
        playArcadeClick();
        let minCd = 14 - Math.min(9, Math.floor(score/150)) - upgradeEffects.fireRate;
        player.shootCooldown = Math.max(3, minCd);
      }

      function mouseShoot() {
        if (player.mouseCooldown > 0 || exploding) return;
        let v = {x: mouseX - player.x, y: mouseY - player.y};
        let len = Math.sqrt(v.x*v.x + v.y*v.y);
        if (len > 0.1) {
          let dx = v.x/len, dy = v.y/len;
          let bulletSpeed = 15 + upgradeEffects.bulletSpeed * 2.6;
          let bulletSize = 11 + upgradeEffects.bulletSize * 3;
          let pierce = 1 + (upgradeEffects.pierce || 0);
          let shots = [];
          if (upgradeEffects.tripleShot > 0) {
            shots.push({dx,dy,angle:0});
            shots.push({dx: Math.cos(Math.atan2(dy,dx)+0.22), dy: Math.sin(Math.atan2(dy,dx)+0.22), angle:0.22});
            shots.push({dx: Math.cos(Math.atan2(dy,dx)-0.22), dy: Math.sin(Math.atan2(dy,dx)-0.22), angle:-0.22});
          } else if (upgradeEffects.doubleShot > 0) {
            shots.push({dx,dy,angle:0});
            shots.push({dx: Math.cos(Math.atan2(dy,dx)+0.13), dy: Math.sin(Math.atan2(dy,dx)+0.13), angle:0.13});
          } else {
            shots.push({dx,dy,angle:0});
          }
          for (let shot of shots) {
            bullets.push({
              x: player.x + shot.dx*player.size,
              y: player.y + shot.dy*player.size,
              dx: shot.dx*bulletSpeed,
              dy: shot.dy*bulletSpeed,
              size: bulletSize,
              color: "#ff00de",
              colorGlow: "#ff00d4",
              pierce: pierce
            });
          }
          playArcadeClick();
          player.mouseCooldown = Math.max(3, 8 - upgradeEffects.fireRate);
        }
      }

      function updateBullets() {
        for (let b of bullets) {
          b.x += b.dx;
          b.y += b.dy;
        }
        bullets = bullets.filter(b =>
          b.x > -24 && b.x < canvas.width+24 && b.y > -24 && b.y < canvas.height+24 && b.pierce > 0
        );
      }

      function spawnEnemy() {
        const types = ["normal"];
        if (difficulty>2) types.push("fast");
        if (difficulty>5) types.push("zigzag");
        let type = types[Math.floor(Math.random()*types.length)];
        const edge = Math.floor(Math.random() * 4);
        let x, y;
        switch(edge) {
          case 0: x = Math.random() * canvas.width; y = -30; break;
          case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
          case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
          case 3: x = -30; y = Math.random() * canvas.height; break;
        }
        const angle = Math.atan2(player.y - y, player.x - x);
        let speed = 1.2 + difficulty*0.21 + Math.random()*0.6;
        if(type==="fast") speed *= 1.41;
        let zigzagPhase = Math.random()*Math.PI*2;
        enemies.push({
          x, y,
          dx: Math.cos(angle) * speed,
          dy: Math.sin(angle) * speed,
          baseAngle: angle,
          angle: Math.random() * Math.PI * 2,
          size: type==="zigzag"?35:25 + Math.random() * 11,
          type,
          zigzagPhase
        });
      }

      function updateEnemies() {
        for (let e of enemies) {
          if(e.type==="zigzag"){
            e.zigzagPhase += 0.19 + difficulty/35;
            let amplitude = 28 + difficulty*3.3;
            e.x += Math.cos(e.baseAngle)*2.1 + Math.cos(e.baseAngle+Math.PI/2)*Math.sin(e.zigzagPhase)*amplitude/11;
            e.y += Math.sin(e.baseAngle)*2.1 + Math.sin(e.baseAngle+Math.PI/2)*Math.sin(e.zigzagPhase)*amplitude/11;
          } else {
            e.x += e.dx;
            e.y += e.dy;
          }
          e.angle += (Math.random() - 0.5) * 0.18;
        }
        enemies = enemies.filter(e =>
          e.x > -70 && e.x < canvas.width + 70 && e.y > -70 && e.y < canvas.height + 70
        );
      }

      function spawnHeal() {
        let margin = 60;
        let x = margin + Math.random()*(canvas.width-margin*2);
        let y = margin + Math.random()*(canvas.height-margin*2);
        heals.push({
          x, y,
          size: 18 + Math.random()*4,
          angle: Math.random()*Math.PI*2
        });
      }

      function updateHeals() {
        for(let h of heals) h.angle += 0.04 + Math.random()*0.05;
      }

      function checkCollisions() {
        if (exploding) return;
        let enemyKilled = false;
        for (let b of bullets) {
          for (let e of enemies) {
            const dx = b.x - e.x;
            const dy = b.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < e.size / 2 + b.size) {
              e.hit = true;
              b.pierce--;
              b.hit = b.pierce <= 0;
              // Score with multiplier
              let sAdd = 10 + Math.floor(difficulty*2.7);
              if (upgradeEffects.scoreBoost) sAdd = Math.floor(sAdd * (1 + 0.08*upgradeEffects.scoreBoost));
              score += sAdd;
              glitchTimer = 5 + Math.random() * 10;
              enemyKilled = true;
              // Life steal
              if (upgradeEffects.healOnKill > 0 && Math.random() < 0.13 * upgradeEffects.healOnKill && player.hp < player.maxHp) {
                player.hp++;
                playHealSound();
              }
            }
          }
        }
        bullets = bullets.filter(b => !b.hit);
        const enemiesHit = enemies.filter(e => e.hit);
        enemies = enemies.filter(e => !e.hit);

        // Show "Nice Job" with 1 in 12 chance per enemy killed (multi-kill = always show at least once)
        if (enemiesHit.length > 0 && Math.random() < (1/12)) {
          showNiceJob();
        }

        for (let e of enemies) {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < e.size / 2 + player.size/1.5) {
            // Shield check
            if (player.shieldTimer > 0) continue;
            if (!gameOver && !exploding) {
              player.hp--;
              playArcadeClick();
              glitchTimer = 44;
              e.hit = true;
              if (player.hp<=0) {
                triggerExplosion();
              }
            }
          }
        }
        enemies = enemies.filter(e => !e.hit);

        for (let h of heals) {
          const dx = player.x - h.x;
          const dy = player.y - h.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < player.size/2 + h.size) {
            h.collected = true;
            playHealSound();
            player.hp = Math.min(player.maxHp, player.hp+1);
            score += 5;
          }
        }
        heals = heals.filter(h => !h.collected);
      }

      function triggerExplosion() {
        // Player death: trigger explosion and fade
        exploding = true;
        explosionParticles = [];
        fadeAlpha = 0;
        explosionTimer = 0;
        // create neon particles
        const particleColors = ["#00fff6", "#fff", "#ff00d4", "#00ffd0", "#ff0045"];
        const count = 42;
        for (let i=0; i<count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = 5 + Math.random() * 5;
          let color = particleColors[Math.floor(Math.random()*particleColors.length)];
          explosionParticles.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle)*speed,
            dy: Math.sin(angle)*speed,
            size: 6 + Math.random()*7,
            color: color,
            alpha: 1.0,
            decay: 0.015 + Math.random()*0.018
          });
        }
        setTimeout(()=>{fadeAlpha = 0;}, 10);
      }

      function updateExplosion() {
        if (!exploding) return;
        for (let p of explosionParticles) {
          p.x += p.dx;
          p.y += p.dy;
          p.dx *= 0.97;
          p.dy *= 0.97;
          p.alpha -= p.decay;
        }
        explosionParticles = explosionParticles.filter(p => p.alpha > 0.01);
        explosionTimer++;
        // Start fade after some frames
        if (explosionTimer > 24) {
          fadeAlpha = Math.min(1, fadeAlpha + fadeStep);
        }
        // When fade fully done, set gameOver
        if (fadeAlpha >= 1 && !gameOver) {
          gameOver = true;
          exploding = false;
          // Shop: Add score to balance, then show shop
          shopData.balance += score;
          saveShopData();
          setTimeout(() => {
            renderShop();
            shopOverlay.style.display = 'flex';
          }, 550);
        }
      }

      function glitchEffect() {
        let html = '';
        for (let i = 0; i < 10 + Math.random() * 24; i++) {
          const top = Math.random() * 100;
          html += `<div style="
            position:absolute;
            left:0; right:0;
            top:${top}vh;
            height:${2 + Math.random() * 3.6}px;
            background:linear-gradient(90deg, #fff0, #00ffd0, #ff00d4, #fff0);
            opacity:${Math.random() * 0.32 + 0.22};
            filter: blur(${Math.random()*1.3}px);
            "></div>`;
        }
        for (let i = 0; i < 5 + Math.random() * 8; i++) {
          const left = Math.random() * 100;
          const top = Math.random() * 100;
          html += `<div style="
            position:absolute;
            left:${left}vw;
            top:${top}vh;
            width:${10+Math.random()*70}px;
            height:${5+Math.random()*22}px;
            background:#fff;
            opacity:${Math.random()*0.24+0.08};
            mix-blend-mode:difference;
            filter: blur(${Math.random()*5.5}px);
            "></div>`;
        }
        if (Math.random() > 0.91) {
          html += `<div style="
            position:absolute;left:0;top:0;right:0;bottom:0;
            background:#fff;
            opacity:0.12;
            "></div>`;
        }
        overlay.innerHTML = html;
        overlay.style.opacity = "1";
      }

      function clearGlitch() {
        overlay.innerHTML = '';
        overlay.style.opacity = "0";
      }

      function restartGame() {
        // Apply upgrades
        upgradeEffects = applyAllUpgradeEffects();
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.hp = 3 + (upgradeEffects.maxHp || 0);
        player.maxHp = player.hp;
        player.speed = 3.2;
        player.shootCooldown = 0;
        player.mouseCooldown = 0;
        player.regenTimer = 0;
        player.shieldTimer = (upgradeEffects.startShield > 0 ? 120 : 0);
        player.bigBombs = upgradeEffects.bigBomb || 0;
        bullets = [];
        enemies = [];
        heals = [];
        score = 0;
        gameOver = false;
        glitchTimer = 0;
        tick = 0;
        spawnTimer = 40;
        healTimer = 0;
        difficulty = 1;
        exploding = false;
        explosionParticles = [];
        fadeAlpha = 0;
        explosionTimer = 0;
        niceJobMsg.style.opacity = "0";
      }

      function useBigBomb() {
        if (player.bigBombs <= 0) return;
        enemies = [];
        player.bigBombs--;
        glitchTimer = 22;
      }

      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!gameOver && !exploding) {
          movePlayer();
          if ((keys[' '] || keys['Space']) && player.shootCooldown === 0) shoot();
          if (mouseDown && player.mouseCooldown === 0) mouseShoot();
          if (player.shootCooldown > 0) player.shootCooldown--;
          if (player.mouseCooldown > 0) player.mouseCooldown--;
          updateBullets();
          updateEnemies();
          updateHeals();
          checkCollisions();
          // Regen
          if (upgradeEffects.regen > 0 && player.hp < player.maxHp) {
            player.regenTimer++;
            if (player.regenTimer > 60 * 20 / (upgradeEffects.regen || 1)) {
              player.hp++;
              player.regenTimer = 0;
              playHealSound();
            }
          }
          // Shield
          if (player.shieldTimer > 0) player.shieldTimer--;
          // SPAWN RATE
          let baseMin = 120 - (upgradeEffects.healDrop*3);
          let minSpawn = Math.max(15, baseMin - Math.floor(tick/90));
          spawnTimer--;
          if (spawnTimer <= 0) {
            spawnEnemy();
            spawnTimer = minSpawn + Math.floor(Math.random()*15);
          }
          difficulty = 1 + Math.floor(score/80);
          healTimer--;
          let healFreq = 445 - Math.min(190, score*2.3) - (upgradeEffects.healDrop*22);
          if ((healTimer<=0 && player.hp<player.maxHp) || (tick%500===0 && heals.length<2)) {
            spawnHeal();
            healTimer = Math.max(90, healFreq);
          }
        }
        drawPlayer();
        drawBullets();
        drawEnemies();
        drawHeals();
        drawUI();
        // Draw explosion and fade if needed
        if (exploding || (gameOver && fadeAlpha > 0)) {
          drawExplosion();
          updateExplosion();
          drawDeathScreen();
        }
        if (glitchTimer > 0 && !exploding) {
          glitchEffect();
          glitchTimer--;
        } else if (!exploding) {
          clearGlitch();
        }
        tick++;
        requestAnimationFrame(gameLoop);
      }

      restartGame();
      gameLoop();
    });
  </script>
</body>
</html>
